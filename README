Compile: make / make all
Run tests: make clean && make TEST=1
Run in qemu: make qemu / make qemu-nox
Debug with gdb: make qemu-gdb / make qemu-nox-gdb
                (in another terminal) gdb

Questions:
1. Processor starts executing 32-bit code in `switch_prot` in boot1.S.
   The instruction that causes this switch is `ljmp	$PROT_MODE_CSEG, $protcseg`, 
   whichsets CS to PROT_MODE_CSEG, which is 0x8 and jumps to protcseg, which is 
   the start of 32-bit code. The processor hence switches from real mode to
   protected mode.
2. The last instruction executed by the boot loader is `jmp %edx` at 0x8f26,
   in the function `exec_kernel` in boot1main.c. The first instruction of the 
   kernel is `cli` at 0x1023f0`.
3. The first instruction of the kernel is at 0x1023f0.
4. Boot loader decides how many sectors it must read in order to fetch the entire 
   kernel from disk by using the program header table in the ELF file. The location
   of the program header table is given in the ELF header by the field `e_phoff`,
   which gives the offset of the start of the program header table relative to the
   start of the ELF file. The number of entries in the program header table is given
   by the field `e_phnum`, also in the ELF header. For each entry of program header,
   the size of memory to read is `p_memsz`, so using this information, the boot loader
   can figure out how many sectors to read.

Brief description of what I implemented:
In this assignment, I implemented the physical memory management layer of the OS.